---
title: "Single Cell RNA-Seq Preprocessing Pipeline"
author: "Rebecca J. Salamon"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    keep_md: true
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(message = FALSE, warning = FALSE, error = FALSE)

```

## Set up Workspace
```{r libraries, include=FALSE}
library(Seurat)              
library(kableExtra)          
library(ggplot2)
library(biomaRt)
library(tidyr)
library(tidyverse)
library(viridis)        
library(hdf5r)
library(DoubletFinder)     
library(patchwork)
library(BiocManager)
library(gprofiler2)
library(glmGamPoi)
library(devtools)
library(scDblFinder)
library(SingleCellExperiment)

```

## Create Seurat object from Cell Ranger filtered matrix object (or open RDS, skip and move to next step)

The `CreateSeuratObject` function allows feature (gene) and cell filtering by minimum cell and feature counts. We will set these to 0 for now in order to explore manual filtering more fully later on.
```{r create_seurat_objects}
salinev6ohda.data <- Read10X_h5("/Users/beckysalamon/Desktop/Cell Ranger Matix Data", use.names = TRUE, unique.features = TRUE)
scRNA_saline_6ohda="all_compartments_salinev6ohda"
seurat_obj <- CreateSeuratObject(counts = salinev6ohda.data, project = scRNA_saline_6ohda, min.cells = 0, min.features = 0, names.field = 2,  names.delim = "\\_")
class(salinev6ohda[["RNA"]])
head(salinev6ohda@meta.data)
```

## Open RDS Seurat object and filter out empty droplets (if created from Cell Ranger raw matrix)

```{r load_seurat_objects}

# Load Seurat object
seurat_obj <- readRDS("/Users/beckysalamon/Desktop/saline-6ohda-scrna-seq/RDS_object/250530_RS_object.RDS")

#rename file names with sample IDs
table(seurat_obj$orig.ident)

#check to make sure you see file names in column titles and rename
seurat_obj$orig.ident <- recode(seurat_obj$orig.ident,
                                "RS01" = "saline",
                                "RS02" = "6OHDA")


#Filter out empty cells (skip if RDS object is from filtered matrix)
  ncol(seurat_obj)                     # Number of cells/barcodes
summary(seurat_obj$nFeature_RNA)    # How many genes detected per barcode
summary(seurat_obj$nCount_RNA)      # How many UMIs per barcode

# Drop empty droplets and very low-quality barcodes
seurat_obj <- subset(seurat_obj, subset = nFeature_RNA > 200 & nCount_RNA > 500)
```

### Mitochondrial gene expression

Filtering on the expression of genes from the mitochondrial genome is not appropriate in all cell types. However, in many tissues, low-quality / dying cells may exhibit extensive mitochondrial contamination. Even when not filtering on mitochondrial expression, the data can be interesting or informative. The `PercentageFeatureSet` function calculates the proportion of counts originating from a set of features. Genes in the human mitochondrial genome begin with 'MT', while those in the mouse mitochondrial genome begin with 'mt'.
```{r percent_MT}
# Identify mitochondrial genes (mouse example: "^mt-" lowercase)
mt_genes <- grep(pattern = "^mt-", x = rownames(seurat_obj), value = TRUE)

# Set the default assay to RNA
DefaultAssay(seurat_obj) <- "RNA"

# Calculate percent mitochondrial gene expression
seurat_obj[["percent.mt"]] <- PercentageFeatureSet(seurat_obj, pattern = "^mt-")

# Store initial cell count
initial_cells <- ncol(seurat_obj)
print(paste("Initial number of cells:", initial_cells))

# Check percent.mt summary and NAs
summary(seurat_obj$percent.mt)


```

### Visualize distribution of metadata values and filter

The `VlnPlot` function produces a composite plot with one panel for each element of the "features" vector. The data are grouped by the provided identity; by default, this is the active identity of the object, which can be accessed using the `Idents()` function, or in the "active.ident" slot.
```{r violins, fig.height=12}
# Visualize QC metrics to determine filtering and normalization
VlnPlot(seurat_obj, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3, raster = FALSE)

```

### Scatter plots

```{r relationships}

FeatureScatter(seurat_obj, feature1 = "nCount_RNA", feature2 = "percent.mt",  pt.size = 0.5, shuffle = TRUE) +
  geom_vline(xintercept = c(200, 60000)) +
  geom_hline(yintercept = 15) 
FeatureScatter(seurat_obj, feature1 = "nFeature_RNA", feature2 = "percent.mt", pt.size = 0.5, shuffle = TRUE) +
  geom_vline(xintercept = c(200, 7500)) +
  geom_hline(yintercept = 15) 
FeatureScatter(seurat_obj, feature1 = "nFeature_RNA", feature2 = "nCount_RNA", pt.size = 0.5, shuffle = TRUE) +
  geom_vline(xintercept = c(200, 7500)) +
  geom_hline(yintercept = 40000) 
 
```

## Cell filtering/QC

The goal of cell filtering is to remove cells with anomolous expression profiles, typically low UMI cells, which may correspond to low-quality cells or background barcodes that made it through the Cell Ranger filtration algorithm. It may also be appropriate to remove outlier cells with extremely high UMI counts. In this case, the proposed cut-offs on the high end of the distributions are quite conservative, in part to reduce the size of the object and speed up analysis during the workshop. These filters can be put in place with the `subset` function.
```{r, cell_filtering}
# Pre-check
seurat_obj
table(seurat_obj$orig.ident)

# Filter out cells with NA in percent.mt and apply thresholds on features and mito content
seurat_obj <- subset(seurat_obj, subset = nFeature_RNA > 200 & nFeature_RNA < 5000 & !is.na(percent.mt) & percent.mt < 6)

# Post-check
seurat_obj
table(seurat_obj$orig.ident)

# Filter out empty droplets and poor-quality cells
seurat_obj <- subset(seurat_obj,
                     subset = nFeature_RNA > 200 & 
                       nFeature_RNA < 5000 & 
                       percent.mt < 5 & 
                       !is.na(percent.mt))

# Confirm how many cells remain 
print(paste("Cells remaining:", ncol(seurat_obj)))

# Post-check
seurat_obj
table(seurat_obj$orig.ident)

```

### Calculate percentage of cells removed
This allows you to determine how mt and nFeatures changes the number of cells removed.
```{r violins, fig.height=12}

# Calculate cells remaining and removed after filtering
filtered_cells <- ncol(seurat_obj)
removed_cells <- initial_cells - filtered_cells

# Print filtering results
print(paste("Cells after filtering:", filtered_cells))
print(paste("Cells removed:", removed_cells))
print(paste("Percentage of cells removed:", round((removed_cells / initial_cells) * 100, 2), "%"))

# Visualize QC metrics post filtering
VlnPlot(seurat_obj, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3, raster = FALSE)

```

## Feature filtering

When creating the base Seurat object, we had the opportunity filter out some genes using the "min.cells" argument. At the time, we set that to 0. Since we didn't filter our features then, we can apply a filter at this point. If we had filtered when the object was created, this would be an opportunity to be more aggressive. The custom code below provides a function that filters genes requiring a min.umi in at least min.cells, or takes a user-provided list of genes.
```{r gene_filter}
# Define gene filtering function
FilterGenes <- function(object, min.umi = 2, min.cells = 10, genes = NULL) {
  genes.use <- NA
  if (!is.null(genes)) {
    genes.use <- intersect(rownames(object), genes)
  } else if (!is.null(min.cells) & !is.null(min.umi)) {
    num.cells <- Matrix::rowSums(GetAssayData(object, slot = "counts") >= min.umi)
    genes.use <- names(num.cells[num.cells >= min.cells])
  }

  if (length(genes.use) == 0 || all(is.na(genes.use))) {
    stop("No genes passed the filtering criteria. Aborting.")
  }

  object <- subset(object, features = genes.use)
  return(object)
}


# Apply gene filter to seurat_obj (already filtered for cells)
seurat_obj_filtered <- FilterGenes(object = seurat_obj, min.umi = 2, min.cells = 10)

# Optionally replace original object with filtered one
seurat_obj <- seurat_obj_filtered

# Check filtering results (optional)
seurat_obj


```

## Normalize data

After filtering, the next step is to normalize the data usig SCtransform. For large datasets, limit variable features and representative cells. 
```{r normalize}
# Normalize and Scale with SCTransform
# ----------------------------
seurat_obj <- SCTransform(
  seurat_obj,
  vst.flavor = "v2", 
  method = "glmGamPoi",            # Use glmGamPoi backend if installed
  variable.features.n = 4000,      # Increase number of variable features
  ncells = 10000,                  # Use 10k representative cells for modeling
  conserve.memory = TRUE,          # Lower memory usage
  verbose = TRUE
) %>%
  RunPCA(verbose = TRUE) %>%
  FindNeighbors(dims = 1:50) %>%
  FindClusters() %>%
  RunUMAP(dims = 1:50) 
```

## Cell cycle assignment

Cell cycle phase can be a significant source of variation in single cell and single nucleus experiments. There are a number of automated cell cycle stage detection methods available for single cell data. For this workshop, we will be using the built-in Seurat cell cycle function, `CellCycleScoring`. This tool compares gene expression in each cell to a list of cell cycle marker genes and scores each barcode based on marker expression. The phase with the highest score is selected for each barcode. Seurat includes a list of cell cycle genes in human single cell data.
```{r human_gene_list}
s.genes <- cc.genes$s.genes
g2m.genes <- cc.genes$g2m.genes
```

For other species, a user-provided gene list may be substituted, or the orthologs of the human gene list used instead.

**Do not run the code below for human experiments!**
```{r convert_list_mouse, eval=FALSE}
# mouse code DO NOT RUN for human data
convertHumanGeneList <- function(x){
  require("biomaRt")
  human = useEnsembl("ensembl",
                     dataset = "hsapiens_gene_ensembl",
                     mirror = "uswest")
  mouse = useEnsembl("ensembl",
                     dataset = "mmusculus_gene_ensembl",
                     mirror = "uswest")
  genes = getLDS(attributes = c("hgnc_symbol"),
                 filters = "hgnc_symbol",
                 values = x ,
                 mart = human,
                 attributesL = c("mgi_symbol"),
                 martL = mouse,
                 uniqueRows=T)
  humanx = unique(genes[, 2])
  print(head(humanx)) # print first 6 genes found to the screen
  return(humanx)
}
# convert lists to mouse orthologs
s.genes = gorth(cc.genes.updated.2019$s.genes, source_organism = "hsapiens", target_organism = "mmusculus")$ortholog_name
g2m.genes = gorth(cc.genes.updated.2019$g2m.genes, source_organism = "hsapiens", target_organism = "mmusculus")$ortholog_name
```

Once an appropriate gene list has been identified, the `CellCycleScoring` function can be run.
```{r CellCycleScoring}
seurat_obj <- CellCycleScoring(seurat_obj,
                            s.features = s.genes,
                            g2m.features = g2m.genes,
                            set.ident = TRUE)
table(seurat_obj@meta.data$Phase) %>%
  kable(table.attr = "style = \"color: black;\"", caption = "# Cells in each Cell Cycle Stage_seurat_obj",
        col.names = c("Stage", "Count"),
        align = "c") %>%
  kable_styling()
```

## Identify variable genes

The function FindVariableFeatures identifies the most highly variable genes (default 2000 genes) by fitting a line to the relationship of log(variance) and log(mean) using loess smoothing, uses this information to standardize the data, then calculates the variance of the standardized data. This helps avoid selecting genes that only appear variable due to their expression level.
```{r find_variable_genes}
Idents(seurat_obj) <- "orig.ident"


seurat_obj <- FindVariableFeatures(object = seurat_obj, selection.method = "vst")
length(VariableFeatures(seurat_obj))

top10 <- head(VariableFeatures(seurat_obj), 10)
top10

var.feat.plot <- VariableFeaturePlot(seurat_obj)
var.feat.plot <- LabelPoints(plot = var.feat.plot, points = top10, repel = TRUE)
var.feat.plot
```


While it is theoretically possible to calculate as many PCs as there are features in the data, typically 100 PCs is more than sufficient. In fact, many of these PCs may explain negligible amounts of variation. Seurat provides a number of ways to visualize the PCA results.

### Principal components plot

The PCA biplot is a scatter plot showing the placement of each cell on two selected components. By default, the first and second PC are used, but any two calculated PCs may be specified. At this point in the analysis, since we are no longer performing QA and filtering, we can move to examining relationships between cells on a per-group rather than per-sample basis.

```{r plot_pca}
DimPlot(seurat_obj, reduction = "pca", dims = c(1,2), shuffle = TRUE)
```

The axes are unit-less; points (cells or nuclei) that are farther apart are more dissimilar on the displayed PC than points that are closer together.

### PCA loadings

Each PC can be imagined as a sort of meta-gene for which every cell has an expression value. The top genes associated with the reduction component (i.e. contributing to a cell's "expression level" of that meta-gene) can be plotted for a selected dimension(s) using the `VizDimLoadings` function.
```{r viz_pca}
VizDimLoadings(seurat_obj, dims = 1:2, nfeatures = 25, reduction = "pca", ncol = 2) + theme_minimal(base_size = 8)

```

### Heat map

Heat maps display similar information. On the x-axis, cells are ordered by their embeddings ("expression" of the PC), while on the y-axis, genes are ordered by PC loading. When fewer than the total number of cells is selected, this results in selection of the cells with the largest absolute value embeddings, which emphasizes variation on the PC.
```{r heatmap_pca}
DimHeatmap(seurat_obj, dims = 1:2, nfeatures = 25, cells = 500, reduction = "pca", balanced = TRUE, slot = "scale.data")
```

### Elbow plot

An elbow plot displays the standard deviations (or approximate singular values if running PCAFast) of the principle components for easy identification of an elbow in the graph. This elbow often corresponds well with the significant PCs and is much faster to run. This is the traditional approach to selecting principal components. The appearance of elbow plots tends to be highly consistent across single cell / single nucleus experiments. Generally, the line approaches zero at around PC 50. This is a reasonable number of PCs to use for the downstream steps.
```{r elbow}
ElbowPlot(seurat_obj, ndims = 50)
```

PCs with a strong enrichment of low p-value genes are identified as significant components. Let's use the first 50 PCs. 50 PCs is quite standard for most all datasets and is widely used as a chosen PC score.

## UMAP [Uniform Manifold Approximation and Projection](https://arxiv.org/pdf/1802.03426v3.pdf) 

UMAP is a dimensionality reduction method that is commonly used in single cell RNA-Seq analysis. Single cell data is extremely high-dimensional; UMAP calculates a nearest neighbor network describing the relationships between cells as measured by the PC loadings of variable genes and creates a low-dimensional space that preserves these relationships.

```{r}
# UMAP colored by sample identity
DimPlot(seurat_obj, reduction = "umap", shuffle = TRUE) 
colnames(seurat_obj@meta.data)
DimPlot(seurat_obj, group.by = "Phase", reduction = "umap", shuffle = TRUE) +
  scale_color_viridis_d()
FeaturePlot(seurat_obj, features = "G2M.Score", reduction = "umap")
```


## Doublet Detection/Removal
Doublets are cells that appear to be, but are not, real cells. There are two major types of doublets: heterotypic and homotypic. *Heterotypic doublets* are formed by cells with distinct transcriptional profiles. *Homotypic doublets* are formed by cells with similar transcriptional profiles. Heterotypic doublets are relatively easier to detect compared with homotypic doublets. Depending on the protocols used to barcode single cells/nuclei, doublet rates vary significantly and it can reach as high as 40%.

[scDblFinder](https://github.com/plger/scDblFinder) The input Seurat object is ideally performed on each sample individually before merging. It's also recommended to remove low-quality cells and outlier clusters prior to doublet detection to improve accuracy. Unlike DoubletFinder, scDblFinder works directly on the expression matrix and does not require manual parameter tuning like pK. It returns a classification column (scDblFinder.class) in seurat_obj@meta.data, which can be used to filter out predicted doublets before downstream steps such as reclustering or visualization.

```{r doublet detection removal} 

# Increase max allowed size for globals to 1 GB (adjust if needed)
options(future.globals.maxSize = 1000 * 1024^2)  # 1000 MB = 1 GB

# Make sure SCT is active
DefaultAssay(seurat_obj) <- "SCT"

# Set cluster identities
Idents(seurat_obj) <- "seurat_clusters"

# Convert to SingleCellExperiment
sce <- as.SingleCellExperiment(seurat_obj)

# Run scDblFinder
sce <- scDblFinder(sce)

# Add results back to Seurat
seurat_obj$scDblFinder.class <- sce$scDblFinder.class
seurat_obj$scDblFinder.score <- sce$scDblFinder.score
seurat_obj$scDblFinder.isDoublet <- sce$scDblFinder.class == "doublet"

# Check classification column from scDblFinder
table(seurat_obj$scDblFinder.class)

# Optionally, print percentage of doublets
n_doublets <- sum(seurat_obj$scDblFinder.class == "doublet")
n_total <- ncol(seurat_obj)
cat("Doublets identified:", n_doublets, "of", n_total, "cells\n")
cat("Percentage doublets:", round(100 * n_doublets / n_total, 2), "%\n")

# Filter out doublets (optional)
seurat_obj <- subset(seurat_obj, subset = scDblFinder.class == "singlet")

# View result
table(seurat_obj$scDblFinder.class)

```



## Recluster singlet datasets
```{r}

seurat_obj <- FindNeighbors(seurat_obj, dims = 1:50)
seurat_obj <- FindClusters(seurat_obj, resolution = 0.5) 
DimPlot(seurat_obj, reduction = "umap", label=TRUE, pt.size = 0.5)


```

## Check Compartments and Feature Counts
```{r QC}
VlnPlot(seurat_obj,features=c("Epcam","cd45","Col1a1","cd31"),pt.size=0.0)
VlnPlot(seurat_obj,features=c("nFeature_RNA","nCount_RNA","percent.mt"),pt.size=0)
```

## Save preprocessing objects
```{r saveRDS}
setwd("/Users/beckysalamon/Desktop/saline-6ohda-scrna-seq/RDS_object/")
saveRDS(seurat_obj, "seurat_obj.std_pipeline_preprocessed_singlets.rds")
```

### Session information
```{r sessioinfo}
sessionInfo()
```
