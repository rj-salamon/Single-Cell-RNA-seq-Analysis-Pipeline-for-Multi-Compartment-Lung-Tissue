---
title: "integration_clustering"
output: rds object
author: Rebecca J. Salamon
date: "2025-08-28"
---

```{r setup, include=FALSE}
#Load libraries
library(Seurat)           # For Seurat object manipulation, RunPCA, RunUMAP, FindClusters, DotPlot, etc.
library(ggplot2)          # For plot theming (used in DotPlot modifications and titles)
library(dplyr)            # For any potential Seurat-based metadata manipulation (implicitly useful)
library(patchwork)        # For combining ggplot-based plots, potentially used in visualization steps
library(Nebulosa)         # For `plot_density()` in generate_marker_plots
library(viridis)          # Used by nebulosa when plotting 
library(igraph)           # Only needed if doing graph-based operations (used internally by Seurat)
library(harmony)
library(sctransform)      # Only required if you preprocess with SCTransform (not shown in functions)
library(readr)            # For reading in custom CSVs if using `read_csv` instead of `read.csv`
library(openxlsx)
library(future)
library(glmGamPoi)  
library(SeuratDisk)
```

## Load object, singlets

```{r load object}

# Load Seurat object
seurat_obj <- readRDS("/Users/beckysalamon/Desktop/saline-6ohda-scrna-seq/RDS_object/seurat_obj.std_pipeline_preprocessed_singlets.rds")

# Check group identities
table(seurat_obj$orig.ident)

# Set batch names
seurat_obj$Method <- factor(seurat_obj$orig.ident)

# Split by condition
obj_list <- SplitObject(seurat_obj, split.by = "Method")
names(obj_list) <- levels(seurat_obj$Method)

# Now name the list for traceability
names(obj_list) <- levels(seurat_obj$Method)

```

## Run Harmony integration 

```{r pressure, echo=FALSE}

# ---------------------------------------------
# 3. Reload and merge
# ---------------------------------------------
merged_obj <- merge(obj_list[[1]], y = obj_list[2:length(obj_list)])

# ---------------------------------------------
# 4. Run Harmony integration
# ---------------------------------------------
library(Seurat)
library(harmony)

# 1. Merge split objects
merged_obj <- merge(obj_list[[1]], y = obj_list[2:length(obj_list)], add.cell.ids = names(obj_list))

# 2. Set default assay to SCT
DefaultAssay(merged_obj) <- "SCT"

# 3. Ensure variable features are set (they may not persist after merge)
merged_obj <- FindVariableFeatures(merged_obj, selection.method = "vst", nfeatures = 3000)

# 4. Scale and run PCA
merged_obj <- ScaleData(merged_obj, verbose = TRUE)
merged_obj <- RunPCA(merged_obj, npcs = 50, verbose = TRUE)

# 5. Run Harmony integration on PCA
merged_obj <- RunHarmony(
  object = merged_obj,
  group.by.vars = "Method",        # your batch variable
  reduction.use = "pca",           # run on PCA embeddings
  dims.use = 1:50
)

# 6. Run UMAP, neighbors, clustering on Harmony embeddings
merged_obj <- RunUMAP(merged_obj, reduction = "harmony", dims = 1:50)
merged_obj <- FindNeighbors(merged_obj, reduction = "harmony", dims = 1:50)
merged_obj <- FindClusters(merged_obj, resolution = 0.2)

# 7. Plot
DimPlot(merged_obj, group.by = "Method", reduction = "umap", label = TRUE)



```
# 7. 6OHDA vs saline Plot
DimPlot(merged_obj, group.by = "Method", reduction = "umap", label = FALSE)


# UMAP plot with custom labels (cell types)
DimPlot(merged_obj, reduction = "umap", group.by = "Identify")

# Visualize the UMAP plot with clusters
DimPlot(merged_obj, reduction = "umap", group.by = "All Compartments Clustered")



## Find neighbors and cluster based on resolution (see below to determine)

```{r pressure, echo=FALSE}

# Set identities to clusters
Idents(merged_obj) <- "seurat_clusters"

# UMAP with cluster labels
DimPlot(merged_obj, reduction = "umap", label = TRUE, repel = TRUE) +
  ggtitle("Clusters by UMAP")

# Confirm SCT model list is intact for FindMarkers compatibility
length(merged_objj@assays$SCT@misc$model.list)

# Run FindAllMarkers on integrated object with SCT assay
markers <- FindAllMarkers(merged_obj, assay = "SCT", layer = "data")

```

## Run clustering 

```{r reclustering}
# Run neighbors (only once)
merged_obj <- FindNeighbors(merged_obj, reduction = "harmony", dims = 1:50)

# Run clustering at resolution 0.2
merged_obj <- FindClusters(merged_obj, resolution = 0.2)

# Add UMAP for this clustering
merged_obj <- RunUMAP(
  merged_obj,
  reduction = "harmony",
  dims = 1:50,
  reduction.name = "umap_res0.2",
  reduction.key = "UMAP0.2_"
)

# Plot UMAP with cluster labels
DimPlot(
  merged_obj,
  reduction = "umap_res0.2",
  group.by = "SCT_snn_res.0.2",
  label = TRUE, pt.size = 0.2
) + ggtitle("Clusters at Resolution 0.2")

```

## Find all markers

```{r pressure, echo=FALSE}

library(usethis)
usethis::edit_r_environ()

# ---------------------
# 0. Set default assay
# ---------------------
DefaultAssay(merged_obj) <- "SCT"

# Confirm data exists and is numeric
str(GetAssayData(merged_obj, layer = "data")[1:10, 1:10])

# ------------------------------------------
# 1. Optional but important: Clear old model
# ------------------------------------------
merged_obj@assays$SCT@misc <- list()

# -----------------------------------------------------
# 2. Normalize using SCTransform with glmGamPoi backend
# -----------------------------------------------------
merged_obj <- SCTransform(
  merged_obj,
  method = "glmGamPoi",
  variable.features.n = 4000,
  conserve.memory = TRUE,
  verbose = TRUE
)

# ------
# 3. PCA
# ------
merged_obj <- RunPCA(merged_obj)

# ------------------------------
# 4. Batch correction via Harmony
# ------------------------------
merged_obj <- RunHarmony(
  object = merged_obj,
  group.by.vars = "Method",     # adjust if your batch variable is named differently
  reduction.use = "pca",
  dims.use = 1:50
)

# -----------------------------
# 5. UMAP, neighbors, clustering
# -----------------------------
merged_obj <- RunUMAP(merged_obj, reduction = "harmony", dims = 1:50)
merged_obj <- FindNeighbors(merged_obj, reduction = "harmony", dims = 1:50)
merged_obj <- FindClusters(merged_obj, resolution = 0.2)

# Save cluster identities
# Run clustering at your desired resolution
merged_obj <- FindClusters(merged_obj, resolution = 0.2)

# Save those cluster identities
merged_obj$SCT_snn_res.0.2 <- Idents(merged_obj)

# Set them as the active identity
Idents(merged_obj) <- merged_obj$SCT_snn_res.0.2

```

## Save new object  

```{r pressure, echo=FALSE}
# Set the active identity to the clustering resolution of interest
Idents(merged_obj) <- "SCT_snn_res.0.2"


# Save Seurat object to file
saveRDS(merged_obj, file = "/Users/beckysalamon/Desktop/saline-6ohda-scrna-seq/RDS_object/seurat_obj_harmony_integrated_res0.2.rds")
```

## Summary info

```{r pressure, echo=FALSE}
cat("Harmony integration completed and object saved.\n")
```

